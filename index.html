<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="ad.orientation" content="portrait,landscape">
    <meta name="ad.size" content="width=300,height=250">
    <title>3D Playable Ad</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
        }
        canvas { display: block; }
        #joystick-container { 
            position: fixed; 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%);
            z-index: 2; 
        }
        #ui {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1; 
        }
        .ui-element {
            margin: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            color: #fff;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            text-shadow: 2px 2px 5px #000;
        }
        #upgrade-bar {
            width: 300px;
            height: 30px; 
            background-color: #ccc;
            border-radius: 15px; 
            overflow: hidden;
            margin: 20px 0; 
        }
        #upgrade-progress {
            width: 0%;
            height: 100%;
            background-color: gold;
            transition: width 0.3s ease-in-out;
        }
        #upgrade-text {
            font-size: 24px; 
            color: gold; 
            text-shadow: 2px 2px 5px black;
            opacity: 0; 
            transition: opacity 0.5s ease-in-out;
        }
    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</head>
<body>
    <div id="joystick-container"></div>
    <div id="ui">
        <div id="upgrade-bar">
            <div id="upgrade-progress"></div>
        </div>
        <div id="upgrade-text">UPGRADED!</div>
        <div class="ui-element">Score: <span id="score">0</span></div>
        <div class="ui-element">Health: <span id="health">100</span></div>
    </div>
    <audio id="hitSound" src="https://assets.mixkit.co/sfx/download/mixkit-small-hit-in-a-game-2072.wav"></audio>
    <audio id="boosterSound" src="https://assets.mixkit.co/sfx/download/mixkit-winning-bleeps-2012.wav"></audio>
    <audio id="coinSound" src="https://www.zedge.net/find/ringtones/coin%20sound"></audio>
    <script>
        $.getScript("https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js")
            .done(function(script, textStatus) {
                console.log("Three.js loaded successfully.");
                $.getScript("https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.2/nipplejs.min.js")
                    .done(function(script, textStatus) {
                        console.log("nipplejs loaded successfully.");
                        $.getScript("https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js")
                            .done(function(script, textStatus) {
                                console.log("GLTFLoader loaded successfully.");
                                init();
                            })
                            .fail(function(jqxhr, settings, exception) {
                                console.error("Failed to load GLTFLoader.");
                            });
                    })
                    .fail(function(jqxhr, settings, exception) {
                        console.error("Failed to load nipplejs.");
                    });
            })
            .fail(function(jqxhr, settings, exception) {
                console.error("Failed to load Three.js.");
            });

        let mixer;
        let particleSystem;
        let cube;
        let rotatingSpheres = [];
        let bullets = [];
        let score = 0;
        let playerHealth = 100;
        let coins = [];

        let upgradeLevel = 0;
        const upgradeThreshold = 50;
        let currentUpgradeProgress = 0;

        const hitSound = document.getElementById('hitSound');
        const boosterSound = document.getElementById('boosterSound');
        const coinSound = document.getElementById('coinSound');

        function init() {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const loader = new THREE.TextureLoader();
            const texture = loader.load('https://storage.googleapis.com/handler-reflections/skybox.jpg', () => {
                const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
                rt.fromEquirectangularTexture(renderer, texture);
                scene.background = rt.texture;
            });

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 5, 5).normalize();
            scene.add(light);

            const planeTexture = loader.load('https://storage.googleapis.com/handler-reflections/plane.png');
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshBasicMaterial({ map: planeTexture });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            const gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load('https://storage.googleapis.com/handler-reflections/model%20(1).glb', function (gltf) {
                cube = gltf.scene;
                cube.scale.set(2, 2, 2);
                cube.position.set(0, 0.5, 0);
                scene.add(cube);

                mixer = new THREE.AnimationMixer(cube);
                gltf.animations.forEach((clip) => {
                    mixer.clipAction(clip).play();
                });

                createRotatingSpheres();
                spawnBooster();
            });

            const particleCount = 1000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = Math.random() * 100 - 50;
                positions[i + 1] = Math.random() * 100;
                positions[i + 2] = Math.random() * 100 - 50;
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.1 });
            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);

            const enemies = [];
            let enemySpeed = 0.02; 

            function createHealthBar(enemy) {
                const healthBarWidth = 2;
                const healthBarHeight = 0.2;

                const backgroundGeometry = new THREE.PlaneGeometry(healthBarWidth, healthBarHeight);
                const backgroundMaterial = new THREE.MeshBasicMaterial({ color: 0x555555 });
                const backgroundBar = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
                backgroundBar.position.set(0, 2.5, 0);
                enemy.add(backgroundBar);

                const foregroundGeometry = new THREE.PlaneGeometry(healthBarWidth, healthBarHeight);
                const foregroundMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const foregroundBar = new THREE.Mesh(foregroundGeometry, foregroundMaterial);
                foregroundBar.position.set(0, 2.5, 0.01);
                enemy.add(foregroundBar);

                enemy.healthBar = foregroundBar;
                enemy.maxHealth = 60;
                enemy.health = enemy.maxHealth;
            }

            function updateHealthBar(enemy) {
                const healthPercentage = enemy.health / enemy.maxHealth;
                enemy.healthBar.scale.set(healthPercentage, 1, 1);
                enemy.healthBar.position.x = (healthPercentage - 1) * 1;
            }

    function spawnEnemy() {
    console.log("Trying to spawn an enemy..."); // Log when spawnEnemy is called
    const enemyGeometry = new THREE.BoxGeometry(1, 5, 1);
    const enemyMaterial = new THREE.MeshPhongMaterial({ color: 0x800080 }); 
    const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
    enemy.position.set(
        Math.random() * 100 - 50,
        2.5,
        Math.random() * 100 - 50
    );
    createHealthBar(enemy);
    enemies.push(enemy);
    scene.add(enemy);
}

let spawnInterval = 1000;
let spawnEnemyInterval = setInterval(spawnEnemy, spawnInterval); 

         

            const boosters = [];
            function spawnBooster() {
                const boosterGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const boosterMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
                const booster = new THREE.Mesh(boosterGeometry, boosterMaterial);
                if (cube) {
                    booster.position.set(
                        cube.position.x + Math.random() * 5 - 2.5,
                        0.3,
                        cube.position.z + Math.random() * 5 - 2.5
                    );
                }
                boosters.push(booster);
                scene.add(booster);
            }

            function spawnCoins(position) {
                const coinCount = 10; 
                for (let i = 0; i < coinCount; i++) {
                    const coinGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                    const coinMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const coin = new THREE.Mesh(coinGeometry, coinMaterial);

                    coin.position.set(
                        position.x + (Math.random() - 0.5) * 2,
                        0.1, 
                        position.z + (Math.random() - 0.5) * 2
                    );

                    coins.push(coin);
                    scene.add(coin);
                }
            }

            const joystick = nipplejs.create({
                zone: document.getElementById('joystick-container'),
                mode: 'static',
                position: { left: '50%', bottom: '60px' },
                color: 'red'
            });

            let joystickDeltaX = 0;
            let joystickDeltaY = 0;

            joystick.on('move', (evt, data) => {
                joystickDeltaX = data.vector.x;
                joystickDeltaY = -data.vector.y;
            });

            joystick.on('end', () => {
                joystickDeltaX = 0;
                joystickDeltaY = 0;
            });

            function createRotatingSpheres() {
                const sphereGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

                const sphereDistance = upgradeLevel > 0 ? 3 : 2;

                for (let i = 0; i < 4; i++) {
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.userData = { hitEnemies: [] };
                    scene.add(sphere);
                    rotatingSpheres.push(sphere);
                }
            }

            function updateRotatingSpheres() {
                const time = Date.now() * 0.002;
                const radius = upgradeLevel > 0 ? 3 : 2;

                rotatingSpheres.forEach((sphere, index) => {
                    const angle = time + (index * Math.PI / 2);
                    const newPosition = new THREE.Vector3(
                        cube.position.x + radius * Math.cos(angle),
                        cube.position.y + 2,
                        cube.position.z + radius * Math.sin(angle)
                    );

                    sphere.position.copy(newPosition);
                });
            }

            function checkSphereCollisions() {
                rotatingSpheres.forEach((sphere) => {
                    enemies.forEach((enemy, enemyIndex) => {
                        const distance = sphere.position.distanceTo(enemy.position);
                        if (distance < 1.5 && !sphere.userData.hitEnemies.includes(enemy)) {
                            console.log('Sphere hit the enemy!');
                            hitSound.play();
                            enemy.health -= 20;
                            updateHealthBar(enemy);
                            sphere.userData.hitEnemies.push(enemy);

                            enemy.material.color.set(0xff0000);
                            setTimeout(() => {
                                enemy.material.color.set(0x800080); 
                            }, 500);

                            const direction = new THREE.Vector3().subVectors(enemy.position, sphere.position).normalize();
                            direction.y = 0; 
                            enemy.position.add(direction.multiplyScalar(5)); 

                            if (enemy.health <= 0) {
                                scene.remove(enemy);
                                enemies.splice(enemyIndex, 1);
                                console.log('Enemy destroyed!');
                                score += 10;
                                spawnCoins(enemy.position); 
                                updateUI();
                            }
                        }
                    });
                });
            }

            let bulletRadius = 3; 
            function shootBullet() {
                const bulletGeometry = new THREE.SphereGeometry(bulletRadius, bulletRadius, bulletRadius);
                const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

                const direction = new THREE.Vector3(0, 0, 1);
                direction.applyQuaternion(cube.quaternion);
                bullet.position.copy(cube.position).add(direction.multiplyScalar(1.5));
                bullet.userData.direction = direction.clone();

                bullets.push(bullet);
                scene.add(bullet);
            }

            let bulletSpeed = 0.5; 
            function updateBullets() {
                bullets.forEach((bullet, index) => {
                    bullet.position.addScaledVector(bullet.userData.direction, bulletSpeed);

                    if (bullet.position.distanceTo(new THREE.Vector3(0, 0, 0)) > 50) {
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                    }
                });
            }

            const raycaster = new THREE.Raycaster();
           function checkBulletCollisions() {
    const sphereRadius = 2; // Adjust this value to increase or decrease the collision area

    bullets.forEach((bullet, bulletIndex) => {
        const bulletSphere = new THREE.Sphere(bullet.position, sphereRadius);

        enemies.forEach((enemy, enemyIndex) => {
            const enemyBoundingBox = new THREE.Box3().setFromObject(enemy);
            const enemyBoundingSphere = enemyBoundingBox.getBoundingSphere(new THREE.Sphere());

            if (bulletSphere.intersectsSphere(enemyBoundingSphere)) {
                hitSound.play();
                scene.remove(bullet);
                bullets.splice(bulletIndex, 1);

                enemy.health -= 20;
                updateHealthBar(enemy);

                enemy.material.color.set(0xff0000);
                setTimeout(() => {
                    enemy.material.color.set(0x800080);
                }, 500);

                if (enemy.health <= 0) {
                    scene.remove(enemy);
                    enemies.splice(enemyIndex, 1);
                    console.log('Enemy destroyed!');
                    score += 10;
                    spawnCoins(enemy.position);
                    updateUI();
                }
            }
        });
    });
}


            function checkCoinCollisions() {
                if (cube) {
                    coins.forEach((coin, coinIndex) => {
                        const distance = cube.position.distanceTo(coin.position);
                        if (distance < 1.5) {
                            console.log('Coin collected!');
                            coinSound.play();
                            scene.remove(coin);
                            coins.splice(coinIndex, 1);
                            score += 1;

                            currentUpgradeProgress += 10;
                            if (currentUpgradeProgress >= upgradeThreshold) {
                                upgradePlayer();
                            }
                            updateUpgradeSlider();
                        }
                    });
                }
            }

            function updateCamera() {
                if (cube) {
                    const offset = new THREE.Vector3(0, 30, 35);
                    const desiredPosition = cube.position.clone().add(offset);
                    camera.position.lerp(desiredPosition, 0.1);
                    camera.lookAt(cube.position);
                }
            }

            function checkBoosterCollisions() {
                if (cube) {
                    boosters.forEach((booster, boosterIndex) => {
                        const distance = cube.position.distanceTo(booster.position);
                        if (distance < 1.5) {
                            console.log('Booster collected!');
                            boosterSound.play();
                            scene.remove(booster);
                            boosters.splice(boosterIndex, 1);

                            rotatingSpheres.forEach(sphere => {
                                sphere.scale.multiplyScalar(1.5);
                            });
                            createRotatingSpheres();
                            score += 20;
                            updateUI();
                        }
                    });
                }
            }

            function moveEnemiesTowardsCube() {
                if (cube) {
                    enemies.forEach((enemy) => {
                        const direction = new THREE.Vector3().subVectors(cube.position, enemy.position).normalize();
                        direction.y = 0;
                        enemy.position.add(direction.multiplyScalar(enemySpeed));
                    });
                }
            }

            function updateUI() {
                document.getElementById('score').textContent = score;
                document.getElementById('health').textContent = playerHealth;
            }

            function updateUpgradeSlider() {
                const upgradePercentage = (currentUpgradeProgress / upgradeThreshold) * 100;
                document.getElementById('upgrade-progress').style.width = upgradePercentage + '%';
            }

            function upgradePlayer() {
                upgradeLevel++;
                currentUpgradeProgress = 0;
                updateUpgradeSlider();

                const upgradeText = document.getElementById('upgrade-text');
                upgradeText.style.opacity = 1;
                setTimeout(() => {
                    upgradeText.style.opacity = 0;
                }, 2000);

                createUpgradeParticles(cube.position);

                switch (upgradeLevel) {
                    case 1:
                        // First upgrade: Start shooting bullets
                        rotatingSpheres.forEach(sphere => {
                            sphere.material.color.set(0xffff00);
                        });
                        break;
                    case 2:
                        // Second upgrade: Increase bullet size
                        bulletRadius = 6;
                        break;
                    case 3:
                        // Third upgrade: Increase bullet speed
                        bulletSpeed = 1;
                        break;
                    // Add more cases for further upgrades
                }
            }

            function createUpgradeParticles(position) {
                const particleCount = 50;
                const particleGeometry = new THREE.BufferGeometry();
                const positions = [];

                for (let i = 0; i < particleCount; i++) {
                    const x = position.x + (Math.random() - 0.5) * 2;
                    const y = position.y + (Math.random() - 0.5) * 2;
                    const z = position.z + (Math.random() - 0.5) * 2;
                    positions.push(x, y, z);
                }

                particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                const particleMaterial = new THREE.PointsMaterial({ 
                    color: 0xffff00, 
                    size: 0.1, 
                    sizeAttenuation: true 
                });
                const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particleSystem);

                let particleLife = 1.0;
                function animateParticles() {
                    if (particleLife <= 0) {
                        scene.remove(particleSystem);
                        return; 
                    }

                    particleLife -= 0.05;
                    particleMaterial.opacity = particleLife;
                    particleSystem.position.y += 0.1;
                    requestAnimationFrame(animateParticles);
                }
                animateParticles();
            }

           let lastShootTime = 0;
const shootInterval = 1000; // Shoot a bullet every 1000 milliseconds (1 second)

function animate(time) {
    requestAnimationFrame(animate);

    if (cube) {
        cube.position.x += joystickDeltaX * 0.2;
        cube.position.z += joystickDeltaY * 0.2;

        if (joystickDeltaX !== 0 || joystickDeltaY !== 0) {
            cube.rotation.y = Math.atan2(joystickDeltaX, joystickDeltaY);
        }
    }

    if (upgradeLevel > 0) {
        updateBullets();
        checkBulletCollisions();

        // Use the time parameter to ensure bullets are shot at uniform intervals
        if (time - lastShootTime >= shootInterval) {
            shootBullet();
            lastShootTime = time; // Reset the shoot timer
        }
    }

    moveEnemiesTowardsCube();
    updateCamera();
    checkBoosterCollisions();
    checkSphereCollisions();
    updateRotatingSpheres();
    checkCoinCollisions();

    if (mixer) {
        mixer.update(0.01);
    }

    const positions = particleSystem.geometry.attributes.position.array;
    for (let i = 1; i < positions.length; i += 3) {
        positions[i] -= 0.1;
        if (positions[i] < 0) {
            positions[i] = 100;
        }
    }
    particleSystem.geometry.attributes.position.needsUpdate = true;

    // Increase enemy spawn frequency over time

    // Increase enemy speed over time
    if (enemySpeed < 0.2) { 
        enemySpeed += 0.0001; 
    }
    renderer.render(scene, camera);
}

animate();

        }
    </script>
</body>
</html>